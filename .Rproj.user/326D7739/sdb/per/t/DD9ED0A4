{
    "collab_server" : "",
    "contents" : "#Author: Sarah P. Flanagan (spflanagan.phd@gmail.com)\n#Purpose: Calculate useful population genetics statistics, plot genome-wide statistics,\n#and run Fst-based selection components analysis\n\n#' Plot statistics genome-wide\n#' @param bp The basepair values (which will be plotted on x-axis).\n#' @param var The variable values to be plotted on the y-axis.\n#' @param y.max The maximum value for the y-axis.\n#' @param x.max The maximum value for the x-axis.\n#' @param rect.xs Whether or not you've already calculated where to plot the rectangles.\n#' Default is NULL, which will identify where to put rectangles?\n#' @param\n#' @export\nplot.genome.wide<-function(bp,var,y.max,x.max, rect.xs=NULL,y.min=0,x.min=0,\n\tplot.new=FALSE, plot.axis=TRUE, rect.color=\"white\",plot.rect=TRUE,\n\tpt.cex=1, pt.col=\"black\"){\n\n\tif(plot.new==TRUE){ par(new=new) }\n\tplot(bp, var,xlab=\"\",ylab=\"\", new=plot.new,\n\t\ttype=\"n\", bg=\"transparent\", axes=F, bty=\"n\",\n\t\txlim=c(x.min,x.max),ylim=c(y.min, y.max))\n\tif(plot.rect==TRUE){\n\t\tnum.rect<-nrow(rect.xs)\n\t\tif(is.null(num.rect)) {\n\t\t\trect(rect.xs[1],y.min,rect.xs[2],y.max,\n\t\t\t\tcol=rect.color, border=NA)\n\t\t} else {\n\t\t\tfor(i in 1:nrow(rect.xs)){\n\t\t\t\trect(rect.xs[i,1],y.min,rect.xs[i,2],y.max,\n\t\t\t\t\tcol=rect.color, border=NA)\n\t\t\t}\n\t\t}\n\t}\n\tif(plot.axis){\n\taxis(2, at = seq(y.min,y.max,round((y.max-y.min)/2, digits=2)),\n\t\tylim = c(y.min, y.max), pos=0,\n\t\tlas=1,tck = -0.01, xlab=\"\", ylab=\"\", cex.axis=0.75)}\n\tpoints(bp, var, pch=19, cex=pt.cex,col=pt.col,\n\t\txlim=c(x.min,x.max),ylim=c(y.min, y.max))\n}\n\n#' Plot genome-wide statistics from a data frame.\n#' @param fst.dat The data.frame containing at least three columns: the statistic to be plotted, the chromosome ID, and the BP ID for each locus. Each row is a locus.\n#' @param ci.dat A vector containing two values, upper and lower cutoff values (in that order).\n#' Points above or below the cutoffs will be colored based on sig.col. Default is NULL, which turns this option off.\n#' @param sig.col A vector containing two color values, the first for points above the upper cutoff value and the second for points below the lower cutoff value.\n#' The defaults are red and yellow.\n#' @param pt.col The color of the points. The default is grey7.\n#' @param fst.name The name of the column containing the statistic to be plotted. Default is \"Fst\".\n#' @param chrom.name The name of the column containing the chromosome information for each locus. Default is \"Chrom\".\n#' @param bp.name The name of the column containing the basepair information for each locus. Default is \"BP\".\n#' @param axis.size The value of cex.axis passed to the plotting of the y-axis. Default is 0.5. Set axis.size = 0 to suppress plotting of the y-axis.\n#' @param scaffold.order A vector or list containing the names of the chromosomes/scaffolds in the order in which you would like them to be plotted.\n#' @param groups A vector indicating which chromosomes to plot (generally to exclude those scaffolds not found in this particular set of statistics due to pruning/filters)\n#' @param print.names A TRUE/FALSE value indicating whether chromosome/scaffold IDs should be printed beneath the x-axis.\n#' @param y.lim The limits for the y-axis.\n#' @examples\n#' od<-fst.plot(plink.both.fst[!is.na(plink.both.fst$Fst),],\n#'  fst.name=\"Fst\",chrom.name=\"Chrom\",bp.name=\"Pos\",axis.size=1,y.lim=c(-2,0.6),\n#'  groups=as.factor(scaffs[scaffs %in% levels(factor(plink.both.fst$Chrom[!is.na(plink.both.fst$Fst)]))]))\n#' @return xes The fst.dat data frame with new values in BP, scaled to be the sequence in which points are plotted based on their position on the chromosome and the order the chromosomes are plotted in.\n#' @notes Used in Flanagan & Jones 2017\n#' @export\nfst.plot<-function(fst.dat,ci.dat=NULL, sig.col=c(\"red\",\"yellow\"),pt.col=\"grey7\",\n\tfst.name=\"Fst\", chrom.name=\"Chrom\", bp.name=\"BP\",axis.size=0.5,\n\tscaffold.order=NULL,groups=NULL,print.names=FALSE,y.lim=NULL){\n\tif(!is.null(scaffold.order)){\n\t\tscaff.ord<-scaffold.order$component_id\n\t\tlgs<-scaffold.order$object\n\t} else{\n\t\tscaff.ord<-levels(factor(fst.dat[,chrom.name]))\n\t\tlgs<-scaff.ord\n\t}\n\tif(!is.null(groups)){\n\t\tlgs<-groups\n\t\tscaff.ord<-groups\n\t}\n  fst.dat[,fst.name]<-as.numeric(as.character(fst.dat[,fst.name]))\n\n\tall.scaff<-split(fst.dat, factor(fst.dat[,chrom.name]))\n\tlast.max<-0\n\trect.xs<-NULL\n\taddition.values<-0\n\txlist<-NULL\n\txs<-NULL\n\tfor(i in 1:length(scaff.ord)){\n\t\tall.scaff[[scaff.ord[i]]]<-\n\t\t\tall.scaff[[scaff.ord[i]]][order(all.scaff[[scaff.ord[i]]][,bp.name]),]\n\t\tall.scaff[[scaff.ord[i]]][,bp.name]<-\n\t\t\tseq(last.max+1,last.max+nrow(all.scaff[[scaff.ord[i]]]),1)\n\t\txs<-c(xs, seq(last.max+1,last.max+nrow(all.scaff[[scaff.ord[i]]]),1))\n\t\tnew.max<-max(xs)\n\t\t#scaffold.order[i,\"new_start\"]<-last.max\n\t\t#scaffold.order[i,\"new_end\"]<-new.max\n\t\trect.xs<-rbind(rect.xs,c(last.max, new.max))\n\t\trownames(rect.xs)[i]<-scaff.ord[i]\n\t\taddition.values<-c(addition.values, new.max)\n\t\tlast.max<-new.max\n\t}\n\t#change BP to plot\n\tx.max<-max(xs)\n\tx.min<-min(xs)\n\tif(is.null(y.lim)){\n  \ty.max<-max(fst.dat[,fst.name])+0.1*max(fst.dat[,fst.name])\n  \ty.min<-min(fst.dat[,fst.name])-0.1*min(fst.dat[,fst.name])\n  \tif(min(fst.dat[,fst.name]) < 0) {\n  \t\ty.min<-min(fst.dat[,fst.name]) - 0.1*min(fst.dat[,fst.name])\n  \t} else {\n  \t\ty.min<-0\n  \t}\n\n  \ty.lim<-c(y.min,y.max)\n\t}\n\tdisplacement<-y.lim[1]-((y.lim[2]-y.lim[1])/30)\n\tplot(c(x.min,x.max),y.lim,xlim=c(x.min,x.max),\n\t\tylim=y.lim, col=pt.col,\n\t\tbty=\"n\",type=\"n\",\taxes=F, xlab=\"\", ylab=\"\")\n\tfor(i in 1:nrow(rect.xs)){\n\t\tif(i%%2 == 0) {\n\t\t\trect.color<-\"white\"\n\t\t} else {\n\t\t\trect.color<-\"gray75\"\n\t\t}\n\t\trect(rect.xs[i,1],y.lim[1],rect.xs[i,2],y.lim[2],\n\t\t\tcol=rect.color, border=NA)\n\t\tif(print.names==T){\n\t\t\ttext(x=mean(all.scaff[[scaff.ord[i]]][\n\t\t\t\tall.scaff[[scaff.ord[i]]]$Chrom==rownames(rect.xs)[i],\n\t\t\t\tbp.name]),\n\t\t\t\ty=displacement,labels=rownames(rect.xs)[i],\n\t\t\t\tadj=1,xpd=T,srt=45)\n\t\t}\n\t}\n\tfor(i in 1:length(scaff.ord)){\n\t\tpoints(all.scaff[[scaff.ord[i]]][,bp.name],\n\t\t\tall.scaff[[scaff.ord[i]]][,fst.name],\n\t\t\tpch=19, cex=0.5,col=pt.col,\n\t\t\txlim=c(x.min,x.max),ylim=y.lim)\n\t  if(!is.null(ci.dat)){\n  \t\ttemp.sig<-all.scaff[[scaff.ord[i]]][all.scaff[[scaff.ord[i]]][,fst.name] >= ci.dat[1],]\n  \t\tpoints(temp.sig[,bp.name], temp.sig[,fst.name],\n  \t\t\tcol=sig.col[1], pch=19, cex=0.5)\n  \t\ttemp.sig<-all.scaff[[scaff.ord[i]]][all.scaff[[scaff.ord[i]]][,fst.name] <= ci.dat[2],]\n  \t\tpoints(temp.sig[,bp.name], temp.sig[,fst.name],\n  \t\t\tcol=sig.col[2], pch=19, cex=0.5)\n\t  }\n\t}\n\tif(axis.size>0){\n\t\taxis(2, at = seq(round(y.lim[1],2),round(y.lim[2],2),\n\t\t\tround((y.lim[2]-y.lim[1])/2, digits=2)),\n\t\t\tylim =y.lim, pos=0,\n\t\t\tlabels=seq(round(y.lim[1],2),round(y.lim[2],2),\n\t\t\t\tround((y.lim[2]-y.lim[1])/2, digits=2)),\n\t\t\tlas=1,tck = -0.01, xlab=\"\", ylab=\"\", cex.axis=axis.size)\n\t}\n\txes<-do.call(\"rbind\",all.scaff)\n\treturn(xes)\n}\n\n#' Read in a vcf file\n#' @param filename The name of the vcf file\n#' @return a dataframe containing the contents of the vcf file, including headers.\n#' @examples\n#' vcf<-parse.vcf(\"batch_1.vcf\")\n#' @notes Used in Flanagan & Jones 2017\n#' @export\nparse.vcf<-function(filename){\n  if(substr(filename,length(filename)-4,length(filename)) != \".vcf\") { filename<-paste(filename,\"vcf\",sep=\".\") }\n  vcf<-read.delim(filename,comment.char=\"#\",sep='\\t',header=F,stringsAsFactors = F)\n  header.start<-grep(\"#CHROM\",scan(filename,what=\"character\"))\n  header<-scan(filename,what=\"character\")[header.start:(header.start+ncol(vcf)-1)]\n  colnames(vcf)<-header\n  return(vcf)\n}\n\n#' Calculate per-locus coverage from a vcf file\n#' @param vcf A data.frame containing data in vcf format.\n#' @param subset A list of the column names of the individuals to be used (optional)\n#' @return cov.dat A data.frame with one row for each locus and 14 columns:\n#'    Chrom: The chromosome\n#'    Pos: The position/BP on the chromosome\n#'    Locus: The Locus ID\n#'    NumMissing: The number of individuals not gentoyped at this locus\n#'    NumPresent: The number of individuals genotyped at this locus\n#'    PropMissing: The proportion of individuals not genotyped at this locus\n#'    AvgCovRef: The average coverage of the reference allele in genotyped individuals\n#'    AvgCovAlt: The average coverage of the alternative allele in genotyped individuals\n#'    AvgCovRatio: The average ration of Reference/Alternative allele coverage\n#'    AvgCovTotal: The average of the number of reference + alternative reads per individual\n#'    CovVariance: The variance in coverage among individuals\n#'    NumHet: The number of individuals genotyped as heterozygotes\n#'    PropHet: The proportion of individuals genotyped as heterozygotes\n#'    TotalNumReads: The total number of reads at this locus\n#' @export\nvcf.cov.loc<-function(vcf.row,subset=NULL){\n  if(is.null(subset)){\n    subset<-colnames(vcf)[10:ncol(vcf)]\n  }\n  cov.dat<-do.call(\"rbind\",apply(vcf[,subset],1,function(vcf.row){\n    cov<-unlist(lapply(vcf.row,function(x){\n      c<-strsplit(as.character(x),split=\":\")[[1]][3]\n      return(c)\n    }))\n    miss<-length(cov[cov==\".,.\"])\n    pres<-length(cov[cov!=\".,.\"])\n    ref<-sum(as.numeric(unlist(lapply(cov[cov!=\".,.\"],\n                                      function(x){\n                                        strsplit(as.character(x),\",\")[[1]][1]\n                                      }))))/pres\n    alt<-sum(as.numeric(unlist(lapply(cov[cov!=\".,.\"],\n                                      function(x){\n                                        strsplit(as.character(x),\",\")[[1]][2]\n                                      }))))/pres\n    tot<-sum(as.numeric(unlist(lapply(cov[cov!=\".,.\"],\n                                      function(x){\n                                        as.numeric(strsplit(as.character(x),\",\")[[1]][1]) +\n                                          as.numeric(strsplit(as.character(x),\",\")[[1]][2])\n                                      }))))\n    var.cov<-var(as.numeric(unlist(lapply(cov[cov!=\".,.\"],\n                                          function(x){\n                                            as.numeric(strsplit(as.character(x),\",\")[[1]][1]) +\n                                              as.numeric(strsplit(as.character(x),\",\")[[1]][2])\n                                          }))))\n    het<-unlist(lapply(vcf.row[subset],function(x){\n      strsplit(as.character(x),split=\":\")[[1]][1]\n    }))\n    het<-length(het[het==\"0/1\" | het==\"1/0\"])\n    return(data.frame(Chrom=vcf.row[1],Pos=vcf.row[\"POS\"],Locus=vcf.row[\"ID\"],\n                      NumMissing=miss, NumPresent=pres,PropMissing=miss/(miss+pres),\n                      AvgCovRef=ref,AvgCovAlt=alt, AvgCovRatio=ref/alt,AvgCovTotal=tot/pres, CovVariance=var.cov,\n                      NumHet=het,PropHet=het/pres,TotalNumReads = tot,stringsAsFactors = F))\n  }))\n  return(data.frame(cov.dat))\n}\n\n#' Calculate per-individual coverage from a vcf file\n#' @param vcf A data.frame containing data in vcf format.\n#' @return icov A data.frame with one row for each individual and columns:\n#'    NumMissing: The number of missing loci\n#'    NumPresent: The number of loci genotyped in this individual\n#'    AvgCovRef: The average coverage for reference alleles across all genotyped loci in this individual\n#'    AvgCovAlt: The average coverage for alternative alleles across all genotyped loci in this individual\n#'    AvgCovTot: The average total coverage (ref + alt coverage) across all genotyped loci in this individual\n#'    PropHet: Proportion of loci at which this individual is heterozygous\n#'    NumReads: The total number of reads for this individual\n#' @export\nvcf.cov.ind<-function(vcf){\n  icov<-as.data.frame(do.call(\"rbind\",apply(vcf,2,function(vcf.col){\n    cov<-unlist(lapply(vcf.col,function(x){\n      c<-strsplit(as.character(x),split=\":\")[[1]][3]\n      return(c)\n    }))\n    miss<-length(cov[cov==\".,.\"])\n    pres<-length(cov[cov!=\".,.\"])\n    ref<-sum(as.numeric(unlist(lapply(cov[cov!=\".,.\"],\n                                      function(x){\n                                        strsplit(as.character(x),\",\")[[1]][1]\n                                      }))))/pres\n    alt<-sum(as.numeric(unlist(lapply(cov[cov!=\".,.\"],\n                                      function(x){\n                                        strsplit(as.character(x),\",\")[[1]][2]\n                                      }))))/pres\n    tot<-sum(as.numeric(unlist(lapply(cov[cov!=\".,.\"],\n                                      function(x){\n                                        as.numeric(strsplit(as.character(x),\",\")[[1]][1]) +\n                                          as.numeric(strsplit(as.character(x),\",\")[[1]][2])\n                                      }))))/pres\n    het<-unlist(lapply(vcf.col,function(x){\n      strsplit(as.character(x),split=\":\")[[1]][1]\n    }))\n    het<-length(het[het==\"0/1\" | het==\"1/0\"])\n    return(list(NumMissing=miss,NumPresent=pres,AvgCovRef=ref,AvgCovAlt=alt,AvgCovTot=tot,PropHet=het/pres, NumReads=tot*pres))\n  })))\n  return(as.data.frame(icov))\n}\n\n#' Calculate pairwise fst between two separate vcf files\n#'\nfst.two.vcf<-function(vcf1.row,vcf2,match.index, cov.thresh=0.2){\n  #match.index is the column used to match the two\n  #use in conjunction with apply\n  #e.g. apply(vcf,1,fst.two.vcf,vcf2=vcf.2,match.index=\"SNP\")\n  hs1<-hs2<-hs<-ht<-0\n  freqall<-gt1<-gt2<-NULL\n  vcf2.row<-vcf2[vcf2[,match.index]%in%vcf1.row[match.index],]\n  if(nrow(vcf2.row)>1)#first make sure we have one reading per locus\n  {\n    print(\"Multiple instances in vcf2.\")\n    fst<-NA\n  }\n  else{\n    if(nrow(vcf2.row)==0)\n    {\n      print(\"No instances in vcf2.\")\n      fst<-NA\n    }else #we're good to go\n    {\n      al1<-vcf.alleles(vcf1.row)\n      al2<-vcf.alleles(vcf2.row)\n      if((length(al1)/2)/(length(vcf1.row)-10)>=cov.thresh & (length(al2)/2)/(ncol(vcf2.row)-10)>=cov.thresh){\n        #calculate frequencies\n        fst<-calc.fst.wright(al1,al2)\n      }else {\n        # print(paste(vcf.row[\"#CHROM\"],vcf.row[\"POS\"],\"fails cov thresh\"),sep=\" \")\n        fst<-data.frame(Hs1=NA,Hs2=NA,Hs=NA,Ht=NA,Fst=NA,NumAlleles=length(factor(c(al1,al2))),\n                        Num1=length(al1),Num2=length(al2)) #it doesn't pass the coverage threshold\n      }\n    }#good to go\n  }\n  return(data.frame(Chrom=vcf1.row[\"#CHROM\"],Pos=vcf1.row[\"POS\"],\n                    Hs1=fst[\"Hs1\"],Hs2=fst[\"Hs2\"],Hs=fst[\"Hs\"],Ht=fst[\"Ht\"],Fst=as.numeric(fst[\"Fst\"]),NumAlleles=fst[\"NumAlleles\"],\n                    Num1=fst[\"Num1\"],Num2=fst[\"Num2\"],stringsAsFactors=FALSE))\n}#end function\n\nvcf.alleles<-function(vcf.row){\n  gt1<-unlist(lapply(vcf.row,function(x){\n    c<-strsplit(as.character(x),split=\":\")[[1]][1]\n    return(c)\n  }))\n  gt1<-gt1[gt1 %in% c(\"0/0\",\"1/0\",\"0/1\",\"1/1\")]\n  gt1[gt1%in%\"1/0\"]<-\"0/1\"\n  gt1<-gsub(pattern = \"0\",replacement = vcf.row[\"REF\"],gt1)\n  gt1<-gsub(pattern = \"1\",replacement = vcf.row[\"ALT\"],gt1)\n  al1<-unlist(strsplit(as.character(gt1),split = \"/\"))\n  return(al1)\n}\n\ncalc.fst.nei<-function(al1,al2){\n  hw<-hb<-fst<-0\n  freq1<-summary(factor(al1))/sum(summary(factor(al1)))\n  freq2<-summary(factor(al2))/sum(summary(factor(al2)))\n  al12<-c(al1,al2)\n  freqall<-summary(as.factor(al12))/\n    sum(summary(as.factor(al12)))\n  if(length(freq1)>1 & length(freq2)>1){ #both must be polymorphic\n    hs1<-1-sum(freq1*freq1)\n    hs2<-1-sum(freq2*freq2)\n    hw<-sum(hs1,hs2)\n    hb<-1-sum(freqall*freqall)\n    fst<-1-(hw/(2*hb))\n  } else {\n    hs1<-1-sum(freq1*freq1)\n    hs2<-1-sum(freq2*freq2)\n    if(length(freqall)<=1){\n      hw<-1\n      fst<-NA\n    } else{\n      hw<-1-sum(freqall*freqall)\n      fst<-NA\n    }\n  }\n  return(data.frame(Hs1=hs1,Hs2=hs2,Hs=hb,Ht=hw,Fst=as.numeric(fst),NumAlleles=length(factor(freqall)),\n                    Num1=length(al1),Num2=length(al2)))\n}\n\n\ncalc.fst.wright<-function(al1,al2){\n  hs<-ht<-fst<-0\n  freq1<-summary(factor(al1))/sum(summary(factor(al1)))\n  freq2<-summary(factor(al2))/sum(summary(factor(al2)))\n  al12<-c(al1,al2)\n  freqall<-summary(as.factor(al12))/\n    sum(summary(as.factor(al12)))\n  if(length(freq1)>1 & length(freq2)>1){ #both must be polymorphic\n    hs1<-1-sum(freq1*freq1)\n    hs2<-1-sum(freq2*freq2)\n    hs<-(hs1*length(al1)+hs2*length(al2))/(length(al1)+length(al2))\n    ht<-1-sum(freqall*freqall)\n    fst<-(ht-hs)/ht\n  } else {\n    hs1<-1-sum(freq1*freq1)\n    hs2<-1-sum(freq2*freq2)\n    if(length(freqall)<=1){\n      ht<-1\n      fst<-NA\n    } else{\n      ht<-1-sum(freqall*freqall)\n      fst<-NA\n    }\n  }\n  return(data.frame(Hs1=hs1,Hs2=hs2,Hs=hs,Ht=ht,Fst=as.numeric(fst),NumAlleles=length(factor(freqall)),\n                    Num1=length(al1),Num2=length(al2)))\n}\n\nfst.one.vcf<-function(vcf.row,group1,group2, cov.thresh=0.2, maf=0.05){\n  al1<-vcf.alleles(vcf.row[group1])\n  al2<-vcf.alleles(vcf.row[group2])\n  f1<-table(al1)/sum(table(al1))\n  f2<-table(al2)/sum(table(al2))\n  if(((length(al2)/2)/(length(group2)-10))>=cov.thresh & ((length(al1)/2)/(length(group1)-10))>=cov.thresh & min(f1,f2)>=maf){\n        fst<-calc.fst.wright(al1,al2)\n  }else {\n    # print(paste(vcf.row[\"#CHROM\"],vcf.row[\"POS\"],\"fails cov thresh\"),sep=\" \")\n    fst<-data.frame(Hs1=NA,Hs2=NA,Hs=NA,Ht=NA,Fst=NA,NumAlleles=length(summary(factor(c(al1,al2)))),\n                    Num1=length(al1),Num2=length(al2)) #it doesn't pass the coverage threshold\n  }\n\n  return(data.frame(Chrom=vcf.row[1],Pos=vcf.row[2],\n                    Hs1=fst[\"Hs1\"],Hs2=fst[\"Hs2\"],Hs=fst[\"Hs\"],Ht=fst[\"Ht\"],Fst=as.numeric(fst[\"Fst\"]),NumAlleles=fst[\"NumAlleles\"],\n                    Num1=fst[\"Num1\"],Num2=fst[\"Num2\"],stringsAsFactors=FALSE))\n\n  return(fst)\n}\n#fsts.both<-do.call(\"rbind\",apply(both.sub,1,fst.one.vcf,group1=c(locus.info,o.ind),group2=c(locus.info,d.ind),cov.thresh=0.5))\n\ncalc.afs.vcf<-function(vcf.row){\n  #use in conjunction with apply\n  #e.g. apply(vcf,1,afs.vcf)\n  al1<-vcf.alleles(vcf.row)\n  #calculate frequencies\n  if(length(al1)>0){\n    freq1<-summary(factor(al1))/sum(summary(factor(al1)))\n    if(length(freq1)==1)\n    {\n      if(names(freq1)==vcf.row[\"REF\"])\n      {\n        freq1<-c(freq1,0)\n        names(freq1)<-unlist(c(vcf.row[\"REF\"],vcf.row[\"ALT\"]))\n      }\n      else\n      {\n        freq1<-c(freq1,0)\n        names(freq1)<-unlist(c(vcf.row[\"ALT\"],vcf.row[\"REF\"]))\n      }\n    }\n    return(data.frame(Chrom=vcf.row[\"#CHROM\"], Pos=vcf.row[\"POS\"], Ref=vcf.row[\"REF\"],\n                      RefFreq=freq1[names(freq1) %in% vcf.row[\"REF\"]],\n                      Alt=vcf.row[\"ALT\"],AltFreq=freq1[names(freq1) %in% vcf.row[\"ALT\"]]))\n  }else{\n    return(data.frame(Chrom=vcf.row[\"#CHROM\"], Pos=vcf.row[\"POS\"], Ref=vcf.row[\"REF\"],\n                      RefFreq=0,Alt=vcf.row[\"ALT\"],AltFreq=0))\n  }\n\n}\n\n\nchoose.one.snp<-function(vcf){\n  keep.col<-colnames(vcf)\n  vcf$id.pos<-paste(vcf$ID,vcf$POS,sep=\".\")\n  sub.vcf<-tapply(vcf$id.pos,vcf$ID, sample,size=1)\n  new.vcf<-vcf[vcf$id.pos %in% sub.vcf,keep.col]\n  return(new.vcf)\n}\n\n\n\nfst.one.plink<-function(raw,group1, group2, cov.thresh=0.2){\n  fst.dat<-data.frame(Locus=character(),\n                      Hs1=numeric(),Hs2=numeric(),Hs=numeric(),Ht=numeric(),Fst=numeric(),NumAlleles=numeric(),\n                      Num1=numeric(),Num2=numeric(),stringsAsFactors=F)\n  grp1<-raw[raw$IID %in% group1,]\n  grp2<-raw[raw$IID %in% group2,]\n  for(i in 7:ncol(raw)){\n    na1<-length(grp1[is.na(grp1[,i]),i])/nrow(grp1)\n    na2<-length(grp2[is.na(grp2[,i]),i])/nrow(grp2)\n    gt1<-grp1[!is.na(grp1[,i]),i]\n    gt2<-grp2[!is.na(grp2[,i]),i]\n    gt1[gt1==\"1\"]<-\"1/2\"\n    gt1[gt1==\"2\"]<-\"2/2\"\n    gt1[gt1==\"0\"]<-\"1/1\"\n    gt2[gt2==\"1\"]<-\"1/2\"\n    gt2[gt2==\"2\"]<-\"2/2\"\n    gt2[gt2==\"0\"]<-\"1/1\"\n\n    if(na1<=(1-cov.thresh)){\n      al1<-unlist(strsplit(as.character(gt1),split = \"/\"))\n      if(na2<=(1-cov.thresh)){\n        al2<-unlist(strsplit(as.character(gt2),split=\"/\"))\n        #calculate frequencies\n        fst<-calc.fst.wright(al1,al2)\n      }\n      else {\n        fst<-data.frame(Hs1=NA,Hs2=NA,Hs=NA,Ht=NA,Fst=NA,NumAlleles=length(factor(c(al1,al2))),\n                        Num1=length(al1),Num2=length(al2)) #gt2 doesn't pass coverage threshold\n      }\n    }else {\n      fst<-data.frame(Hs1=NA,Hs2=NA,Hs=NA,Ht=NA,Fst=NA,NumAlleles=length(factor(c(al1,al2))),\n                      Num1=length(al1),Num2=length(al2)) #it doesn't pass the coverage threshold\n    }\n    fst.dat[(i-6),]<-cbind(as.character(colnames(raw)[i]),fst[\"Hs1\"],fst[\"Hs2\"],as.numeric(fst[\"Hs\"]),fst[\"Ht\"],\n                           as.numeric(fst[\"Fst\"]),fst[\"NumAlleles\"],fst[\"Num1\"],fst[\"Num2\"])\n\n  }\n  return(fst.dat)\n}#end fst.one.plink\n\nextract.gt.vcf<-function(vcf){\n  if(length(strsplit(as.character(vcf[1,10]),\":\")[[1]])>1){\n    new<-vcf[,1:3]\n    for(i in 10:ncol(vcf)){\n      new<-cbind(new,\n                 sapply(vcf[,i],function(x) {\n                   strsplit(as.character(x),\":\")[[1]][1]})\n      )\n    }\n    colnames(new)<-colnames(vcf[,c(1:3,10:ncol(vcf))])\n    vcf<-new\n  }\n  return(vcf)\n}\n\ninfer.mat.alleles<-function(dad.kid, vcf){\n  #dad.kid<-read.table(\"both.dad.kid.pairs.txt\")\n  vcf<-extract.gt.vcf(vcf)\n  mat<-apply(dad.kid,1,function(x){\n    mom<-apply(vcf,1,function(y){\n      d1<-strsplit(y[x[1]],\"/\")[[1]][1]\n      d2<-strsplit(y[x[1]],\"/\")[[1]][2]\n      k1<-strsplit(y[x[2]],\"/\")[[1]][1]\n      k2<-strsplit(y[x[2]],\"/\")[[1]][2]\n      mom_allele <- \".\"\n      if (d1 == d2 && k1 == k2) #the case where both are homozygous\n      {\n        if (d1 == k1)\n          mom_allele <- d1\n      }\n      if (d1 == d2 && k1 != k2) #the case where dad is homozygous but kid is het\n      {\n        if (d1 == k1)\n          mom_allele <- k2\n        if (d1 == k2)\n          mom_allele <- k1\n      }\n      if (d1 != d2 && k1 == k2) #the case where dad is het but off is hom\n      {\n        if (d1 == k1 || d2 == k1)\n          mom_allele <- k1;\n      }\n      if (d1 != d2 && k1 != k2) #if they're both hets you can't do anything with it.\n      mom_allele <- \".\"\n      if (d1 == \".\" || k1 == \".\")\n        mom_allele <- \".\"\n      return(c(y[1:9],mom.allele))\n    })\n\n  })\n}\n\nmerge.vcfs<-function(vcf1,vcf2, vcf.name=\"merge.vcf\"){\n  vcf1<-extract.gt.vcf(vcf1)\n  vcf2<-extract.gt.vcf(vcf2)\n  col.id<-c(colnames(vcf1)[1:3],colnames(vcf1)[!(colnames(vcf1) %in%\n                                                   colnames(vcf2))])\n  vcf1a<-vcf1[,col.id]\n  vcf1a$index<-paste(vcf1a$`#CHROM`,vcf1a$ID,vcf1a$POS,sep=\".\")\n  vcf2$index<-paste(vcf2$`#CHROM`,vcf2$ID,vcf2$POS,sep=\".\")\n  vcf<-merge(vcf1a,vcf2, by=\"index\")\n  addedon<-vcf[duplicated(vcf$index),\"index\"]\n  if(!is.null(dim(addedon))) vcf<-vcf[!(vcf$index %in% addedon),]\n  drops<-c(\"index\",\"#CHROM.y\",\"POS.y\",\"ID.y\")\n  vcf<-vcf[,!(colnames(vcf) %in% drops)]\n  colnames(vcf)[1:3]<-c(\"CHROM\",\"POS\",\"ID\")\n  write.table(vcf,vcf.name,col.names=T,row.names=F,\n              quote=F,sep='\\t')\n  return(vcf)\n}\n\ngwsca<-function(vcf,locus.info,group1,group2,prop.ind.thresh=0.5,maf.cutoff=0.05){\n  sel<-do.call(\"rbind\",apply(vcf,1,fst.one.vcf,c(locus.info,group1),c(locus.info,group2),\n    cov.thresh=prop.ind.thresh,maf=maf.cutoff))\n  sel<-sel[!is.na(sel$Fst),]\n  sel$Chi<-2*((sel$Num1+sel$Num2)/2)*sel$Fst\n  sel$Chi.p<-1-pchisq(sel$Chi,1)\n  sel$Chi.p.adj<-p.adjust(sel$Chi.p,method=\"BH\")\n  return(sel)\n}\n\npairwise.fst<-function(ped,allele1,allele2,pop.order){\n  #V1 of ped should be pop index\n  ped.split<-split(ped[,c(allele1,allele2)], factor(ped[,1]))\n  dat.var<-as.data.frame(setNames(\n    replicate(length(pop.order),numeric(0), simplify = F), pop.order))\n  for(i in 1:(length(pop.order)-1)){\n    for(j in (i+1):length(pop.order)){\n      pop1<-factor(ped.split[[pop.order[i]]][ped.split[[pop.order[i]]]!=\"0\"])\n      pop2<-factor(ped.split[[pop.order[j]]][ped.split[[pop.order[j]]]!=\"0\"])\n      freq1<-summary(pop1)/sum(summary(pop1))\n      freq2<-summary(pop2)/sum(summary(pop2))\n      freqall<-summary(as.factor(c(pop1,pop2)))/\n        sum(summary(as.factor(c(pop1,pop2))))\n      if(length(freq1)>1){ hs1<-2*freq1[1]*freq1[2]\n      } else {\n        hs1<-0\n      }\n      if(length(freq2)>1){ hs2<-2*freq2[1]*freq2[2]\n      } else {\n        hs2<-0\n      }\n      if(length(freqall)>1){\n        hs<-mean(c(hs1,hs2))\n        ht<-2*freqall[1]*freqall[2]\n        fst<-(ht-hs)/ht\n      }\n      if(length(freqall)<=1){ fst<-1 }\n      dat.var[pop.order[i],pop.order[j]]<-fst\n    }\n  }\n  dat.var<-rbind(dat.var,rep(NA, ncol(dat.var)))\n  rownames(dat.var)<-colnames(dat.var)\n  return(as.matrix(dat.var))\n}\n\n#***************************************************************************#\n#CALCULATE ISOLATION BY DISTANCE PER LOCUS\n#***************************************************************************#\nfst.ibd.byloc<-function(ped.file,dist.mat,pop.order){\n  results.mantel<-data.frame()\n  for(i in seq(7,ncol(ped.file),2)){\n    res<-mantel.rtest(\n      as.dist(t(pairwise.fst(ped.file,i,i+1,pop.order))),\n      as.dist(t(dist.mat)), nrepet=9999)\n    results.mantel<-rbind(results.mantel,cbind(res$obs,res$pvalue))\n  }\n  results.mantel<-as.data.frame(results.mantel)\n  colnames(results.mantel)<-c(\"Obs\",\"P\")\n  return(results.mantel)\n}\n\n#***************************************************************************#\n#CALCULATE PAIRWISE PST BETWEEN POPULATION PAIRS\n#***************************************************************************#\npairwise.pst<-function(dat, pop.order){\n  #first column must be pop id/grouping factor\n  library(nlme)\n  dat.split<-split(dat, factor(dat[,1]))\n  dat.var<-as.data.frame(setNames(\n    replicate(length(pop.order),numeric(0), simplify = F), pop.order))\n  for(i in 1:(length(pop.order)-1)){\n    for(j in (i+1):length(pop.order)){\n      temp.data<-rbind(as.data.frame(dat.split[[pop.order[i]]]),\n                       as.data.frame(dat.split[[pop.order[j]]]))\n      colnames(temp.data)<-c(\"PopID\",\"Var\")\n      temp.data$PopID<-factor(temp.data$PopID)\n      anv <- lme(fixed=Var ~ 1, random=~1|PopID,data=temp.data)\n      varcomp <- VarCorr(anv)\n      v.btwn<- as.numeric(varcomp[1])\n      v.wthn <- as.numeric(varcomp[2])\n      pst <- v.btwn/(v.btwn+2*v.wthn)\n      dat.var[pop.order[i],pop.order[j]]<-pst\n      #aov.var<-summary.aov(\n      #\taov(temp.data[,2]~temp.data[,1]))[[1]]$`Sum Sq`\n      #aov.df<-summary.aov(\n      #\taov(temp.data[,2]~temp.data[,1]))[[1]]$`Df`\n      #dat.var[pop.order[i],pop.order[j]]<-aov.var[2]/(aov.var[2]+\n      #\t(2*(aov.var[1]/(aov.df[2]-1))))\n    }\n  }\n  dat.var<-rbind(dat.var,rep(NA, ncol(dat.var)))\n  rownames(dat.var)<-colnames(dat.var)\n  return(dat.var)\n}\n\n#***************************************************************************#\n#CALCULATE PAIRWISE PSTS FOR ALL TRAITS AND TEST FOR IBD\n#***************************************************************************#\nall.traits.pst.mantel<-function(trait.df,comp.df,id.index){\n  results.mantel<-data.frame()\n  for(i in 3:ncol(trait.df)){\n    res<-mantel.rtest(\n      as.dist(t(pairwise.pst(trait.df[,c(id.index,i)],pop.order))),\n      as.dist(t(comp.df)), nrepet=9999)\n    results.mantel<-rbind(results.mantel,cbind(res$obs,res$pvalue))\n  }\n  results.mantel<-as.data.frame(results.mantel)\n  rownames(results.mantel)<-colnames(trait.df)[3:ncol(trait.df)]\n  colnames(results.mantel)<-c(\"Obs\",\"P\")\n  return(results.mantel)\n}\n\n\n#***************************************************************************#\n#COMPARE FST AND PST PER LOCUS\n#***************************************************************************#\nfst.pst.byloc<-function(ped.file,trait.df,pop.order,trait.ind){\n  results.list<-list()\n  for(j in 3:ncol(trait.df)){\n    results.mantel<-data.frame()\n    for(i in seq(7,ncol(ped.file),2)){\n      res<-mantel.rtest(\n        as.dist(t(pairwise.fst(ped.file,i,i+1,pop.order))),\n        as.dist(t(pairwise.pst(trait.df[,c(trait.ind,j)],pop.order))),\n        nrepet=9999)\n      results.mantel<-rbind(results.mantel,cbind(res$obs,res$pvalue))\n    }\n    results.mantel<-as.data.frame(results.mantel)\n    colnames(results.mantel)<-c(\"Obs\",\"P\")\n    results.list<-append(results.list,data.frame(results.mantel))\n  }\n  #names(results.list)<-colnames(trait.df)[3:ncol(trait.df)]\n  return(results.list)\n}\n\n#***************************************************************************#\n#CALCULATE STANDARD ERROR OF THE MEAN\n#***************************************************************************#\nsem<-function(x){\n  sem<-sd(x)/sqrt(length(x))\n  return(sem)\n}\n\n#***************************************************************************#\n#PLOT ANY GENOME-WIDE STATISTIC\n#***************************************************************************#\nplotting.genome.wide<-function(bp,var,y.max,x.max, rect.xs=NULL,y.min=0,x.min=0,\n                               plot.new=FALSE, plot.axis=TRUE, rect.color=\"white\",plot.rect=TRUE,\n                               pt.cex=1, pt.col=\"black\"){\n  #********************************************\n  #this function plots a variable without scaffold info.\n  #feed it the basepair (x) values and variable (y) values\n  #*********************************************\n  if(plot.new==TRUE){ par(new=new) }\n  plot(bp, var,xlab=\"\",ylab=\"\", new=plot.new,\n       type=\"n\", bg=\"transparent\", axes=F, bty=\"n\",\n       xlim=c(x.min,x.max),ylim=c(y.min, y.max))\n  if(plot.rect==TRUE){\n    num.rect<-nrow(rect.xs)\n    if(is.null(num.rect)) {\n      rect(rect.xs[1],y.min,rect.xs[2],y.max,\n           col=rect.color, border=NA)\n    } else {\n      for(i in 1:nrow(rect.xs)){\n        rect(rect.xs[i,1],y.min,rect.xs[i,2],y.max,\n             col=rect.color, border=NA)\n      }\n    }\n  }\n  if(plot.axis){\n    axis(2, at = seq(y.min,y.max,round((y.max-y.min)/2, digits=2)),\n         ylim = c(y.min, y.max), pos=0,\n         las=1,tck = -0.01, xlab=\"\", ylab=\"\", cex.axis=0.75)}\n  points(bp, var, pch=19, cex=pt.cex,col=pt.col,\n         xlim=c(x.min,x.max),ylim=c(y.min, y.max))\n}\n\n#***************************************************************************#\n##AUTOMATED FST PLOTTING\n#***************************************************************************#\nplotting.fsts.scaffs<-function(fst.dat, fst.name=\"Fst\",chrom.name=\"Chr\",\n                               bp.name=\"BP\", pt.lty=0,pt.col=\"grey7\",new=T,\n                               ci.dat=NULL, pt.cex=1,y.lab=NULL,axis.size=0.5,scaffold.order=NULL,\n                               groups=NULL,print.names=FALSE,pt.pch=19,\n                               sig.col=\"dark green\", col.pt.pch=8, col.pt.cex=2){\n  if(!is.null(scaffold.order)){\n    scaff.ord<-scaffold.order$component_id\n    lgs<-scaffold.order$object\n  } else{\n    scaff.ord<-levels(factor(fst.dat[,chrom.name]))\n    lgs<-scaff.ord\n  }\n  if(!is.null(groups)){\n    lgs<-groups\n    scaff.ord<-groups\n  }\n  all.scaff<-split(fst.dat, factor(fst.dat[,chrom.name]))\n  last.max<-0\n  rect.xs<-NULL\n  addition.values<-0\n  xlist<-NULL\n  xs<-NULL\n  for(i in 1:length(scaff.ord)){\n    all.scaff[[scaff.ord[i]]]<-\n      all.scaff[[scaff.ord[i]]][order(all.scaff[[scaff.ord[i]]][,bp.name]),]\n    all.scaff[[scaff.ord[i]]][,bp.name]<-\n      seq(last.max+1,last.max+nrow(all.scaff[[scaff.ord[i]]]),1)\n    xs<-c(xs, seq(last.max+1,last.max+nrow(all.scaff[[scaff.ord[i]]]),1))\n    new.max<-max(xs)\n    #scaffold.order[i,\"new_start\"]<-last.max\n    #scaffold.order[i,\"new_end\"]<-new.max\n    rect.xs<-rbind(rect.xs,c(last.max, new.max))\n    rownames(rect.xs)[i]<-scaff.ord[i]\n    addition.values<-c(addition.values, new.max)\n    last.max<-new.max\n  }\n  #change BP to plot\n  x.max<-max(xs)\n  x.min<-min(xs)\n  y.max<-max(fst.dat[,fst.name])+0.1*max(fst.dat[,fst.name])\n  y.min<-min(fst.dat[,fst.name])-0.1*min(fst.dat[,fst.name])\n  if(min(fst.dat[,fst.name]) < 0) {\n    y.min<-min(fst.dat[,fst.name]) - 0.1*min(fst.dat[,fst.name])\n  } else {\n    y.min<-0\n  }\n  displacement<-y.min-((y.max-y.min)/30)\n  if(new==T){\n    plot(c(x.min,x.max),c(y.min,y.max),xlim=c(x.min,x.max),\n         ylim=c(y.min, y.max),\n         bty=\"n\",type=\"n\",\taxes=F, xlab=\"\", ylab=\"\")\n    for(i in 1:nrow(rect.xs)){\n      if(i%%2 == 0) {\n        rect.color<-\"white\"\n      } else {\n        rect.color<-\"gray75\"\n      }\n      rect(rect.xs[i,1],y.min,rect.xs[i,2],y.max,\n           col=rect.color, border=NA)\n      if(print.names==T){\n        text(x=mean(all.scaff[[scaff.ord[i]]][\n          all.scaff[[scaff.ord[i]]]$Chrom==rownames(rect.xs)[i],\n          bp.name]),\n          y=displacement,labels=rownames(rect.xs)[i],\n          adj=1,xpd=T,srt=45)\n      }\n    }\n  }\n  for(i in 1:length(scaff.ord)){\n    if(pt.lty==0){\n      points(all.scaff[[scaff.ord[i]]][,bp.name],\n             all.scaff[[scaff.ord[i]]][,fst.name],\n             pch=pt.pch, cex=0.5,col=pt.col,\n             xlim=c(x.min,x.max),ylim=c(y.min, y.max))\n    } else {\n      lines(all.scaff[[scaff.ord[i]]][,bp.name],\n            all.scaff[[scaff.ord[i]]][,fst.name],\n            lty=pt.lty, cex=0.5,col=pt.col,\n            xlim=c(x.min,x.max),ylim=c(y.min, y.max))\n\n    }\n    temp.sig<-all.scaff[[scaff.ord[i]]][all.scaff[[scaff.ord[i]]][,fst.name] >= ci.dat[1],]\n    points(temp.sig[,bp.name], temp.sig[,fst.name],\n           col=sig.col[1], pch=col.pt.pch, cex=col.pt.pch)\n    temp.sig<-all.scaff[[scaff.ord[i]]][all.scaff[[scaff.ord[i]]][,fst.name] <= ci.dat[2],]\n    points(temp.sig[,bp.name], temp.sig[,fst.name],\n           col=sig.col[2], pch=col.pt.pch, cex=col.pt.pch)\n  }\n  if(axis.size>0){\n    axis(2, at = seq(round(y.min,2),round(y.max,2),\n                     round((y.max-y.min)/2, digits=2)),\n         ylim = c(y.min, y.max), pos=0,\n         labels=seq(round(y.min,2),round(y.max,2),\n                    round((y.max-y.min)/2, digits=2)),\n         las=1,tck = -0.01, xlab=\"\", ylab=\"\", cex.axis=axis.size)\n  }\n  xes<-do.call(\"rbind\",all.scaff)\n  return(xes)\n}\n\n#***************************************************************************#\n##REORDER A DATAFRAME\n#***************************************************************************#\nreorder.df<-function(dat,order.list){\n  #dat has to have the grouping IDs in row 1\n  #those grouping ids must match the factors in order.list\n  dat.sep<-split(dat, dat[,1])\n  dat.new<-dat.sep[[order.list[1]]]\n  for(i in 2:length(order.list)){\n    dat.new<-rbind(dat.new, dat.sep[[order.list[i]]])\n  }\n  return(dat.new)\n}\n\n\n\n\n#***************************************************************************#\n#PLOT A STRUCTURE BARPLOT\n#***************************************************************************#\n\nplotting.structure<-function(structure.out, k, pop.order,\n                             filename=paste(\"str.k\",k,\".jpeg\",sep=\"\"),make.file=TRUE,\n                             plot.new=TRUE,colors=NULL,xlabel=TRUE,ylabel=NULL){\n  str.split<-split(structure.out,structure.out[,1])\n  if(is.null(colors)){\n    bar.colors<-rainbow(k,s=0.5)\n  } else {\n    bar.colors<-colors\n  }\n  if(make.file==TRUE){\n    jpeg(filename,width=7, height=1.25, units=\"in\", res=300)\n    par(mfrow=c(1,length(str.split)))\n  }\n  #par(mfrow=c(1,length(str.split)),mar=c(1,0,0,0), oma=c(1,0,0,0),cex=0.5)\n  for(i in 1:length(str.split)){\n    pop.index<-pop.order[i]\n    barplot(height=as.matrix(t(str.split[[pop.index]][,-1])),\n            beside=FALSE, space=0,\tborder=NA, col=bar.colors,\n            xlab=\"\", ylab=\"\", xaxt='n', yaxt='n')#, new=plot.new)\n    if(xlabel==TRUE){\n      mtext(pop.index, 1, line=0.5, cex=1, outer=F)}\n    if(!is.null(ylabel)){\n      if(i == 1) { mtext(ylabel,2,cex=1) }\n    }\n  }\n  if(make.file==TRUE) {dev.off()}\n}\n\n\n\n",
    "created" : 1484184849504.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "15|27|39|0|\n65|63|157|0|\n166|30|173|0|\n194|43|233|0|\n246|27|274|0|\n",
    "hash" : "170762126",
    "id" : "DD9ED0A4",
    "lastKnownWriteTime" : 1484189062,
    "last_content_update" : 1484196576399,
    "path" : "~/gwscaR/R/gwscaR.R",
    "project_path" : "R/gwscaR.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}