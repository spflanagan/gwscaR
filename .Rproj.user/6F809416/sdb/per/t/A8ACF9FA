{
    "collab_server" : "",
    "contents" : "#Author: Sarah P. Flanagan (spflanagan.phd@gmail.com)\n#Purpose: Calculate useful population genetics statistics, plot genome-wide statistics,\n#and run Fst-based selection components analysis\n\n#' Plot genome-wide statistics from a data frame.\n#' @param fst.dat The data.frame containing at least three columns: the statistic to be plotted, the chromosome ID, and the BP ID for each locus. Each row is a locus.\n#' @param ci.dat A vector containing two values, upper and lower cutoff values (in that order).\n#' Points above or below the cutoffs will be colored based on sig.col. Default is NULL, which turns this option off.\n#' @param sig.col A vector containing two color values, the first for points above the upper cutoff value and the second for points below the lower cutoff value.\n#' The defaults are red and yellow.\n#' @param pt.col The color of the points. The default is grey7.\n#' @param fst.name The name of the column containing the statistic to be plotted. Default is \"Fst\".\n#' @param chrom.name The name of the column containing the chromosome information for each locus. Default is \"Chrom\".\n#' @param bp.name The name of the column containing the basepair information for each locus. Default is \"BP\".\n#' @param axis.size The value of cex.axis passed to the plotting of the y-axis. Default is 0.5. Set axis.size = 0 to suppress plotting of the y-axis.\n#' @param scaffold.order A vector or list containing the names of the chromosomes/scaffolds in the order in which you would like them to be plotted.\n#' @param groups A vector indicating which chromosomes to plot (generally to exclude those scaffolds not found in this particular set of statistics due to pruning/filters)\n#' @param print.names A TRUE/FALSE value indicating whether chromosome/scaffold IDs should be printed beneath the x-axis.\n#' @param y.lim The limits for the y-axis.\n#' @param group.boundaries A data.frame with first column naming the chromosomes/linkage groups, second column having the last number of loci on the chromosome for indexing purposes.\n#' e.g.:\n#'  Chrom   End\n#'  LG1     3945850\n#'  LG2     435215\n#' This parameter is used to make multiple plots from the same overall dataset have the same widths.\n#' @examples\n#' od<-fst.plot(plink.both.fst[!is.na(plink.both.fst$Fst),],\n#'  fst.name=\"Fst\",chrom.name=\"Chrom\",bp.name=\"Pos\",axis.size=1,y.lim=c(-2,0.6),\n#'  groups=as.factor(scaffs[scaffs %in% levels(factor(plink.both.fst$Chrom[!is.na(plink.both.fst$Fst)]))]))\n#' @return xes The fst.dat data frame with new values in BP, scaled to be the sequence in which points are plotted based on their position on the chromosome and the order the chromosomes are plotted in.\n#' @notes Used in Flanagan & Jones 2017\n#' NOT QUITE RIGHT - BIG GAPS\n#' @export\nfst.plot<-function(fst.dat,ci.dat=NULL, sig.col=c(\"red\",\"yellow\"),pt.col=\"grey7\",\n                   fst.name=\"Fst\", chrom.name=\"Chrom\", bp.name=\"BP\",axis.size=0.5,\n                   scaffold.order=NULL,groups=NULL,print.names=FALSE,y.lim=NULL,\n                   group.boundaries=NULL){\n\n  if(!is.null(scaffold.order)){\n    scaff.ord<-scaffold.order$component_id\n    lgs<-scaffold.order$object\n  } else{\n    if(!is.null(group.boundaries)){\n      scaff.ord<-levels(factor(group.boundaries[,1]))\n      lgs<-scaff.ord\n    }else{\n      scaff.ord<-levels(factor(fst.dat[,chrom.name]))\n      lgs<-scaff.ord\n    }\n  }\n  if(!is.null(groups)){\n    lgs<-groups\n    scaff.ord<-groups\n  }\n  fst.dat[,fst.name]<-as.numeric(as.character(fst.dat[,fst.name]))\n  these.scaffs<-scaff.ord[scaff.ord %in% factor(fst.dat[,chrom.name])]\n  all.scaff<-split(fst.dat, factor(fst.dat[,chrom.name]))\n\n  group.boundaries<-group.boundaries[scaff.ord,]\n  last.max<-0\n  rect.xs<-NULL\n  addition.values<-0\n  xlist<-NULL\n  #set up the rectangles\n  for(i in 1:length(scaff.ord)){\n    if(is.null(group.boundaries)){\n      new.max<-max(last.max+nrow(all.scaff[[scaff.ord[i]]]))\n    }else{\n      new.max<-group.boundaries[scaff.ord[i],2]+last.max\n    }\n    rect.xs<-rbind(rect.xs,c(last.max, new.max))\n    rownames(rect.xs)[i]<-scaff.ord[i]\n    addition.values<-c(addition.values, new.max)\n    last.max<-new.max\n  }\n  rownames(rect.xs)<-scaff.ord\n  for(i in 1:length(all.scaff)){\n    if(is.null(group.boundaries)){\n      #then this is done by relative position only\n      all.scaff[[i]]<-all.scaff[[i]][order(all.scaff[[i]][,bp.name]),]\n      all.scaff[[i]][,bp.name]<-\n        seq(rect.xs[rownames(rect.xs) %in% names(all.scaff)[i],1],rect.xs[rownames(rect.xs) %in% names(all.scaff)[i],1]+nrow(all.scaff[[i]]),1)\n    }else{\n      #then it takes genome space into account\n\n      all.scaff[[i]]<-\n        all.scaff[[i]][order(all.scaff[[i]][,bp.name]),]\n      all.scaff[[i]][,bp.name]<-\n        as.numeric(rect.xs[rownames(rect.xs) %in% names(all.scaff)[i],1])+as.numeric(all.scaff[[i]][,bp.name])\n\n    }\n  }\n  #change BP to plot\n  x.max<-max(rect.xs)\n  x.min<-min(rect.xs)\n  if(is.null(y.lim)){\n    y.max<-max(fst.dat[,fst.name])+0.1*max(fst.dat[,fst.name])\n    y.min<-min(fst.dat[,fst.name])-0.1*min(fst.dat[,fst.name])\n    if(min(fst.dat[,fst.name]) < 0) {\n      y.min<-min(fst.dat[,fst.name]) - 0.1*min(fst.dat[,fst.name])\n    } else {\n      y.min<-0\n    }\n\n    y.lim<-c(y.min,y.max)\n  }\n  displacement<-y.lim[1]-((y.lim[2]-y.lim[1])/30)\n  plot(c(x.min,x.max),y.lim,xlim=c(x.min,x.max),\n       ylim=y.lim, col=pt.col,\n       bty=\"n\",type=\"n\",\taxes=F, xlab=\"\", ylab=\"\")\n  for(i in 1:nrow(rect.xs)){\n    if(i%%2 == 0) {\n      rect.color<-\"white\"\n    } else {\n      rect.color<-\"gray75\"\n    }\n    rect(rect.xs[i,1],y.lim[1],rect.xs[i,2],y.lim[2],\n         col=rect.color, border=NA)\n    if(print.names==T){\n      text(x=mean(rect.xs[i,]),\n           y=displacement,labels=rownames(rect.xs)[i],\n           adj=1,xpd=T,srt=45)\n    }\n  }\n  for(i in 1:length(all.scaff)){\n    points(all.scaff[[i]][,bp.name],\n           all.scaff[[i]][,fst.name],\n           pch=19, cex=0.5,col=pt.col,\n           xlim=c(x.min,x.max),ylim=y.lim)\n    if(!is.null(ci.dat)){\n      temp.sig<-all.scaff[[i]][all.scaff[[i]][,fst.name] >= ci.dat[1],]\n      points(temp.sig[,bp.name], temp.sig[,fst.name],\n             col=sig.col[1], pch=19, cex=0.5)\n      temp.sig<-all.scaff[[i]][all.scaff[[i]][,fst.name] <= ci.dat[2],]\n      points(temp.sig[,bp.name], temp.sig[,fst.name],\n             col=sig.col[2], pch=19, cex=0.5)\n    }\n  }\n  if(axis.size>0){\n    axis(2, at = seq(round(y.lim[1],2),round(y.lim[2],2),\n                     round((y.lim[2]-y.lim[1])/2, digits=2)),\n         ylim =y.lim, pos=0,\n         labels=seq(round(y.lim[1],2),round(y.lim[2],2),\n                    round((y.lim[2]-y.lim[1])/2, digits=2)),\n         las=1,tck = -0.01, xlab=\"\", ylab=\"\", cex.axis=axis.size)\n  }\n  xes<-do.call(\"rbind\",all.scaff)\n  return(xes)\n}\n\n\n#' Read in a vcf file\n#' @param filename The name of the vcf file\n#' @return a dataframe containing the contents of the vcf file, including headers.\n#' @examples\n#' vcf<-parse.vcf(\"batch_1.vcf\")\n#' @notes Used in Flanagan & Jones 2017\n#' @export\nparse.vcf<-function(filename){\n  if(substr(filename,length(filename)-4,length(filename)) != \".vcf\") { filename<-paste(filename,\"vcf\",sep=\".\") }\n  vcf<-read.delim(filename,comment.char=\"#\",sep='\\t',header=F,stringsAsFactors = F)\n  header.start<-grep(\"#CHROM\",scan(filename,what=\"character\"))\n  header<-scan(filename,what=\"character\")[header.start:(header.start+ncol(vcf)-1)]\n  colnames(vcf)<-header\n  return(vcf)\n}\n\n#' Calculate per-locus coverage from a vcf file\n#' @param vcf A data.frame containing data in vcf format.\n#' @param subset A list of the column names of the individuals to be used (optional)\n#' @return cov.dat A data.frame with one row for each locus and 14 columns:\n#'    Chrom: The chromosome\n#'    Pos: The position/BP on the chromosome\n#'    Locus: The Locus ID\n#'    NumMissing: The number of individuals not gentoyped at this locus\n#'    NumPresent: The number of individuals genotyped at this locus\n#'    PropMissing: The proportion of individuals not genotyped at this locus\n#'    AvgCovRef: The average coverage of the reference allele in genotyped individuals\n#'    AvgCovAlt: The average coverage of the alternative allele in genotyped individuals\n#'    AvgCovRatio: The average ration of Reference/Alternative allele coverage\n#'    AvgCovTotal: The average of the number of reference + alternative reads per individual\n#'    CovVariance: The variance in coverage among individuals\n#'    NumHet: The number of individuals genotyped as heterozygotes\n#'    PropHet: The proportion of individuals genotyped as heterozygotes\n#'    TotalNumReads: The total number of reads at this locus\n#' @export\nvcf.cov.loc<-function(vcf.row,subset=NULL){\n  if(is.null(subset)){\n    subset<-colnames(vcf)[10:ncol(vcf)]\n  }\n  cov.dat<-do.call(\"rbind\",apply(vcf[,subset],1,function(vcf.row){\n    cov<-unlist(lapply(vcf.row,function(x){\n      c<-strsplit(as.character(x),split=\":\")[[1]][3]\n      return(c)\n    }))\n    miss<-length(cov[cov==\".,.\"])\n    pres<-length(cov[cov!=\".,.\"])\n    ref<-sum(as.numeric(unlist(lapply(cov[cov!=\".,.\"],\n                                      function(x){\n                                        strsplit(as.character(x),\",\")[[1]][1]\n                                      }))))/pres\n    alt<-sum(as.numeric(unlist(lapply(cov[cov!=\".,.\"],\n                                      function(x){\n                                        strsplit(as.character(x),\",\")[[1]][2]\n                                      }))))/pres\n    tot<-sum(as.numeric(unlist(lapply(cov[cov!=\".,.\"],\n                                      function(x){\n                                        as.numeric(strsplit(as.character(x),\",\")[[1]][1]) +\n                                          as.numeric(strsplit(as.character(x),\",\")[[1]][2])\n                                      }))))\n    var.cov<-var(as.numeric(unlist(lapply(cov[cov!=\".,.\"],\n                                          function(x){\n                                            as.numeric(strsplit(as.character(x),\",\")[[1]][1]) +\n                                              as.numeric(strsplit(as.character(x),\",\")[[1]][2])\n                                          }))))\n    het<-unlist(lapply(vcf.row[subset],function(x){\n      strsplit(as.character(x),split=\":\")[[1]][1]\n    }))\n    het<-length(het[het==\"0/1\" | het==\"1/0\"])\n    return(data.frame(Chrom=vcf.row[1],Pos=vcf.row[\"POS\"],Locus=vcf.row[\"ID\"],\n                      NumMissing=miss, NumPresent=pres,PropMissing=miss/(miss+pres),\n                      AvgCovRef=ref,AvgCovAlt=alt, AvgCovRatio=ref/alt,AvgCovTotal=tot/pres, CovVariance=var.cov,\n                      NumHet=het,PropHet=het/pres,TotalNumReads = tot,stringsAsFactors = F))\n  }))\n  return(data.frame(cov.dat))\n}\n\n#' Calculate per-individual coverage from a vcf file\n#' @param vcf A data.frame containing data in vcf format.\n#' @return icov A data.frame with one row for each individual and columns:\n#'    NumMissing: The number of missing loci\n#'    NumPresent: The number of loci genotyped in this individual\n#'    AvgCovRef: The average coverage for reference alleles across all genotyped loci in this individual\n#'    AvgCovAlt: The average coverage for alternative alleles across all genotyped loci in this individual\n#'    AvgCovTot: The average total coverage (ref + alt coverage) across all genotyped loci in this individual\n#'    PropHet: Proportion of loci at which this individual is heterozygous\n#'    NumReads: The total number of reads for this individual\n#' @export\nvcf.cov.ind<-function(vcf){\n  icov<-as.data.frame(do.call(\"rbind\",apply(vcf,2,function(vcf.col){\n    cov<-unlist(lapply(vcf.col,function(x){\n      c<-strsplit(as.character(x),split=\":\")[[1]][3]\n      return(c)\n    }))\n    miss<-length(cov[cov==\".,.\"])\n    pres<-length(cov[cov!=\".,.\"])\n    ref<-sum(as.numeric(unlist(lapply(cov[cov!=\".,.\"],\n                                      function(x){\n                                        strsplit(as.character(x),\",\")[[1]][1]\n                                      }))))/pres\n    alt<-sum(as.numeric(unlist(lapply(cov[cov!=\".,.\"],\n                                      function(x){\n                                        strsplit(as.character(x),\",\")[[1]][2]\n                                      }))))/pres\n    tot<-sum(as.numeric(unlist(lapply(cov[cov!=\".,.\"],\n                                      function(x){\n                                        as.numeric(strsplit(as.character(x),\",\")[[1]][1]) +\n                                          as.numeric(strsplit(as.character(x),\",\")[[1]][2])\n                                      }))))/pres\n    het<-unlist(lapply(vcf.col,function(x){\n      strsplit(as.character(x),split=\":\")[[1]][1]\n    }))\n    het<-length(het[het==\"0/1\" | het==\"1/0\"])\n    return(list(NumMissing=miss,NumPresent=pres,AvgCovRef=ref,AvgCovAlt=alt,AvgCovTot=tot,PropHet=het/pres, NumReads=tot*pres))\n  })))\n  return(as.data.frame(icov))\n}\n\n#' Calculate pairwise fst between two separate vcf files\n#' @param vcf1 A data.frame containing genotype information in vcf format\n#' @param vcf2 A data.frame containing genotype information in vcf format\n#' @param match.index The column used to match the two. Usually I make a column of the chromosome and position as a SNP index.\n#' @param cov.thresh A proportion of the individuals needed to be sampled in each of the populations. Default is 0.2\n#' @param maf A minimum allele frequency (default is 0.05)\n#' @return out A data.frame with columns:\n#' Hs1 (expected heterozygosity in pop 1), Hs2 (expected heterozygosity in pop2),\n#' Hs (expected heterozygosity within pops), Ht (expected heterozygosity between pops),\n#' Fst, NumAlleles, Num1 (number of individuals in pop1), and Num2 (number of individuals in pop2)\n#' @export\nfst.two.vcf<-function(vcf1,vcf2,match.index, cov.thresh=0.2){\n  #match.index is the column used to match the two\n  #use in conjunction with apply\n  #e.g. apply(vcf,1,fst.two.vcf,vcf2=vcf.2,match.index=\"SNP\")\n  out<-apply(vcf1,1,function(vcf1.row){\n    hs1<-hs2<-hs<-ht<-0\n    freqall<-gt1<-gt2<-NULL\n    vcf2.row<-vcf2[vcf2[,match.index]%in%vcf1.row[match.index],]\n    if(nrow(vcf2.row)>1)#first make sure we have one reading per locus\n    {\n      print(\"Multiple instances in vcf2.\")\n      fst<-NA\n    }\n    else{\n      if(nrow(vcf2.row)==0)\n      {\n        print(\"No instances in vcf2.\")\n        fst<-NA\n      }else #we're good to go\n      {\n        al1<-vcf.alleles(vcf1.row)\n        al2<-vcf.alleles(vcf2.row)\n        if((length(al1)/2)/(length(vcf1.row)-10)>=cov.thresh & (length(al2)/2)/(ncol(vcf2.row)-10)>=cov.thresh){\n          #calculate frequencies\n          fst<-calc.fst.wright(al1,al2)\n        }else {\n          # print(paste(vcf.row[\"#CHROM\"],vcf.row[\"POS\"],\"fails cov thresh\"),sep=\" \")\n          fst<-data.frame(Hs1=NA,Hs2=NA,Hs=NA,Ht=NA,Fst=NA,NumAlleles=length(factor(c(al1,al2))),\n                          Num1=length(al1),Num2=length(al2)) #it doesn't pass the coverage threshold\n        }\n      }#good to go\n    }\n\n    return(fst)\n  })\n  return(out)\n}\n\n#' Extract alleles from a vcf row\n#' @param vcf.row A vcf row (containing only the individuals and locus info)\n#' @return al1 A list of alleles\n#' @export\nvcf.alleles<-function(vcf.row){\n  gt1<-unlist(lapply(vcf.row,function(x){\n    c<-strsplit(as.character(x),split=\":\")[[1]][1]\n    return(c)\n  }))\n  gt1<-gt1[gt1 %in% c(\"0/0\",\"1/0\",\"0/1\",\"1/1\")]\n  gt1[gt1%in%\"1/0\"]<-\"0/1\"\n  gt1<-gsub(pattern = \"0\",replacement = vcf.row[\"REF\"],gt1)\n  gt1<-gsub(pattern = \"1\",replacement = vcf.row[\"ALT\"],gt1)\n  al1<-unlist(strsplit(as.character(gt1),split = \"/\"))\n  return(al1)\n}\n\n#' Calculate Fst using Nei's formulation (1-(Hw/2Hb))\n#' @param al1 A list of alleles in pop1\n#' @param al2 A list of alleles in pop2\n#' @return data.frame with columns Hs1, Hs2, Hs, Ht, Fst, NumAlleles, Num1 and Num2\n#' @export\ncalc.fst.nei<-function(al1,al2){\n  hw<-hb<-fst<-0\n  freq1<-summary(factor(al1))/sum(summary(factor(al1)))\n  freq2<-summary(factor(al2))/sum(summary(factor(al2)))\n  al12<-c(al1,al2)\n  freqall<-summary(as.factor(al12))/\n    sum(summary(as.factor(al12)))\n  if(length(freq1)>1 & length(freq2)>1){ #both must be polymorphic\n    hs1<-1-sum(freq1*freq1)\n    hs2<-1-sum(freq2*freq2)\n    hw<-sum(hs1,hs2)\n    hb<-1-sum(freqall*freqall)\n    fst<-1-(hw/(2*hb))\n  } else {\n    hs1<-1-sum(freq1*freq1)\n    hs2<-1-sum(freq2*freq2)\n    if(length(freqall)<=1){\n      hw<-1\n      fst<-NA\n    } else{\n      hw<-1-sum(freqall*freqall)\n      fst<-NA\n    }\n  }\n  return(data.frame(Hs1=hs1,Hs2=hs2,Hs=hb,Ht=hw,Fst=as.numeric(fst),NumAlleles=length(factor(freqall)),\n                    Num1=length(al1),Num2=length(al2)))\n}\n\n#' Calculate Fst using Wright's formulation ((ht-hs)/ht)\n#' @param al1 A list of alleles in pop1\n#' @param al2 A list of alleles in pop2\n#' @return data.frame with columns Hs1, Hs2, Hs, Ht, Fst, NumAlleles, Num1 and Num2\n#' @export\ncalc.fst.wright<-function(al1,al2){\n  hs<-ht<-fst<-0\n  freq1<-summary(factor(al1))/sum(summary(factor(al1)))\n  freq2<-summary(factor(al2))/sum(summary(factor(al2)))\n  al12<-c(al1,al2)\n  freqall<-summary(as.factor(al12))/\n    sum(summary(as.factor(al12)))\n  if(length(freq1)>1 & length(freq2)>1){ #both must be polymorphic\n    hs1<-1-sum(freq1*freq1)\n    hs2<-1-sum(freq2*freq2)\n    hs<-(hs1*length(al1)+hs2*length(al2))/(length(al1)+length(al2))\n    ht<-1-sum(freqall*freqall)\n    fst<-(ht-hs)/ht\n  } else {\n    hs1<-1-sum(freq1*freq1)\n    hs2<-1-sum(freq2*freq2)\n    if(length(freqall)<=1){\n      ht<-1\n      fst<-NA\n    } else{\n      ht<-1-sum(freqall*freqall)\n      fst<-NA\n    }\n  }\n  return(data.frame(Hs1=hs1,Hs2=hs2,Hs=hs,Ht=ht,Fst=as.numeric(fst),NumAlleles=length(factor(freqall)),\n                    Num1=length(al1),Num2=length(al2)))\n}\n\n#' Calculate fsts from a single vcf\n#' @param vcf A data.frame in vcf format\n#' @param group1 A list of individual names for pop1\n#' @param group2 A list of individual names for pop2\n#' @param cov.thresh A proportion of individuals required for genotyping individuals (default is 0.2)\n#' @param maf A minimum allele frequency (default is 0.05)\n#' @return out A data.frame with columns:\n#' Hs1 (expected heterozygosity in pop 1), Hs2 (expected heterozygosity in pop2),\n#' Hs (expected heterozygosity within pops), Ht (expected heterozygosity between pops),\n#' Fst, NumAlleles, Num1 (number of individuals in pop1), and Num2 (number of individuals in pop2)\n#' @export\nfst.one.vcf<-function(vcf,group1,group2, cov.thresh=0.2, maf=0.05){\n  out<-do.call(\"rbind\",apply(vcf,1,function(vcf.row){\n    al1<-vcf.alleles(vcf.row[group1])\n    al2<-vcf.alleles(vcf.row[group2])\n    f1<-table(al1)/sum(table(al1))\n    f2<-table(al2)/sum(table(al2))\n    if(((length(al2)/2)/(length(group2)-10))>=cov.thresh & ((length(al1)/2)/(length(group1)-10))>=cov.thresh & min(f1,f2)>=maf){\n          fst<-calc.fst.wright(al1,al2)\n    }else {\n      # print(paste(vcf.row[\"#CHROM\"],vcf.row[\"POS\"],\"fails cov thresh\"),sep=\" \")\n      fst<-data.frame(Hs1=NA,Hs2=NA,Hs=NA,Ht=NA,Fst=NA,NumAlleles=length(summary(factor(c(al1,al2)))),\n                      Num1=length(al1),Num2=length(al2)) #it doesn't pass the coverage threshold\n    }\n\n    return(fst)\n  }))\n  return(out)\n}\n\n#' A function that calculates the allele frequencies from a vcf\n#' @param vcf A data.frame with genotype data in vcf format\n#' @return out A data.frame with columns Chrom, Pos, Ref (the reference allele),\n#' RefFreq (frequency of reference allele), Alt (alternative allele), and AltFreq (frequency of the alternative allele)\n#' @export\ncalc.afs.vcf<-function(vcf){\n  #use in conjunction with apply\n  out<-apply(vcf,1,function(vcf.row){\n    al1<-vcf.alleles(vcf.row)\n    #calculate frequencies\n    if(length(al1)>0){\n      freq1<-summary(factor(al1))/sum(summary(factor(al1)))\n      if(length(freq1)==1)\n      {\n        if(names(freq1)==vcf.row[\"REF\"])\n        {\n          freq1<-c(freq1,0)\n          names(freq1)<-unlist(c(vcf.row[\"REF\"],vcf.row[\"ALT\"]))\n        }\n        else\n        {\n          freq1<-c(freq1,0)\n          names(freq1)<-unlist(c(vcf.row[\"ALT\"],vcf.row[\"REF\"]))\n        }\n      }\n      return(data.frame(Chrom=vcf.row[\"#CHROM\"], Pos=vcf.row[\"POS\"], Ref=vcf.row[\"REF\"],\n                        RefFreq=freq1[names(freq1) %in% vcf.row[\"REF\"]],\n                        Alt=vcf.row[\"ALT\"],AltFreq=freq1[names(freq1) %in% vcf.row[\"ALT\"]]))\n    }else{\n      return(data.frame(Chrom=vcf.row[\"#CHROM\"], Pos=vcf.row[\"POS\"], Ref=vcf.row[\"REF\"],\n                        RefFreq=0,Alt=vcf.row[\"ALT\"],AltFreq=0))\n    }\n  })\n  return(out)\n\n}\n\n#' Choose one SNP per RAD locus from a vcf\n#' @param vcf A data.frame in vcf format\n#' @return new.vcf A data.frame with only one SNP per RAD locus\n#' @export\nchoose.one.snp<-function(vcf){\n  keep.col<-colnames(vcf)\n  vcf$id.pos<-paste(vcf$ID,vcf$POS,sep=\".\")\n  sub.vcf<-tapply(vcf$id.pos,vcf$ID, sample,size=1)\n  new.vcf<-vcf[vcf$id.pos %in% sub.vcf,keep.col]\n  return(new.vcf)\n}\n\n\n#' Calculate pairwise fsts from a dataset in ped format\n#' @param raw A data.frame with data in ped format\n#' @param group1 A list with the individuals in group 1\n#' @param group2 A list with the individuals in group 2\n#' @param cov.thresh A threshold for the number of individuals in the populations (default is 0.2)\n#' @return fst.dat A data.frame with columns:\n#'  Locus Name = the locus name\n#'  Hs1 = expected heterozygosity in pop 1\n#'  Hs2 = expected heterozygosity in pop 2\n#'  Hs = expected heterozygosity within populations\n#'  Ht = expected heterozygosity among populations\n#'  Fst = Fst\n#'  NumAlleles = number of alleles at the locus\n#'  Num1 = the number of individuals in pop 1\n#'  Num2 = the number of individuals in pop 2\n#' @export\nfst.one.plink<-function(raw,group1, group2, cov.thresh=0.2){\n  fst.dat<-data.frame(Locus=character(),\n                      Hs1=numeric(),Hs2=numeric(),Hs=numeric(),Ht=numeric(),Fst=numeric(),NumAlleles=numeric(),\n                      Num1=numeric(),Num2=numeric(),stringsAsFactors=F)\n  grp1<-raw[raw$IID %in% group1,]\n  grp2<-raw[raw$IID %in% group2,]\n  for(i in 7:ncol(raw)){\n    na1<-length(grp1[is.na(grp1[,i]),i])/nrow(grp1)\n    na2<-length(grp2[is.na(grp2[,i]),i])/nrow(grp2)\n    gt1<-grp1[!is.na(grp1[,i]),i]\n    gt2<-grp2[!is.na(grp2[,i]),i]\n    gt1[gt1==\"1\"]<-\"1/2\"\n    gt1[gt1==\"2\"]<-\"2/2\"\n    gt1[gt1==\"0\"]<-\"1/1\"\n    gt2[gt2==\"1\"]<-\"1/2\"\n    gt2[gt2==\"2\"]<-\"2/2\"\n    gt2[gt2==\"0\"]<-\"1/1\"\n\n    if(na1<=(1-cov.thresh)){\n      al1<-unlist(strsplit(as.character(gt1),split = \"/\"))\n      if(na2<=(1-cov.thresh)){\n        al2<-unlist(strsplit(as.character(gt2),split=\"/\"))\n        #calculate frequencies\n        fst<-calc.fst.wright(al1,al2)\n      }\n      else {\n        fst<-data.frame(Hs1=NA,Hs2=NA,Hs=NA,Ht=NA,Fst=NA,NumAlleles=length(factor(c(al1,al2))),\n                        Num1=length(al1),Num2=length(al2)) #gt2 doesn't pass coverage threshold\n      }\n    }else {\n      fst<-data.frame(Hs1=NA,Hs2=NA,Hs=NA,Ht=NA,Fst=NA,NumAlleles=length(factor(c(al1,al2))),\n                      Num1=length(al1),Num2=length(al2)) #it doesn't pass the coverage threshold\n    }\n    fst.dat[(i-6),]<-cbind(as.character(colnames(raw)[i]),fst[\"Hs1\"],fst[\"Hs2\"],as.numeric(fst[\"Hs\"]),fst[\"Ht\"],\n                           as.numeric(fst[\"Fst\"]),fst[\"NumAlleles\"],fst[\"Num1\"],fst[\"Num2\"])\n\n  }\n  return(fst.dat)\n}#end fst.one.plink\n\n#' A function to pull out only the genotype fields from vcf-format data\n#' @param vcf A data.frame with genotype data in vcf format\n#' @return vcf A new vcf with only the GT data\n#' @export\nextract.gt.vcf<-function(vcf){\n  if(length(strsplit(as.character(vcf[1,10]),\":\")[[1]])>1){\n    new<-vcf[,1:3]\n    for(i in 10:ncol(vcf)){\n      new<-cbind(new,\n                 sapply(vcf[,i],function(x) {\n                   strsplit(as.character(x),\":\")[[1]][1]})\n      )\n    }\n    colnames(new)<-colnames(vcf[,c(1:3,10:ncol(vcf))])\n    vcf<-new\n  }\n  return(vcf)\n}\n\n#' A function to infer maternal alleles from a vcf file\n#' @param dad.kid A data.frame with two columns, each one with matching father and offspring IDs\n#' @param vcf A data.frame with genomic data in vcf format\n#' @return mat A data.frame of inferred maternal alleles\n#' @export\ninfer.mat.alleles<-function(dad.kid, vcf){\n  #dad.kid<-read.table(\"both.dad.kid.pairs.txt\")\n  vcf<-extract.gt.vcf(vcf)\n  mat<-apply(dad.kid,1,function(x){\n    mom<-apply(vcf,1,function(y){\n      d1<-strsplit(y[x[1]],\"/\")[[1]][1]\n      d2<-strsplit(y[x[1]],\"/\")[[1]][2]\n      k1<-strsplit(y[x[2]],\"/\")[[1]][1]\n      k2<-strsplit(y[x[2]],\"/\")[[1]][2]\n      mom_allele <- \".\"\n      if (d1 == d2 && k1 == k2) #the case where both are homozygous\n      {\n        if (d1 == k1)\n          mom_allele <- d1\n      }\n      if (d1 == d2 && k1 != k2) #the case where dad is homozygous but kid is het\n      {\n        if (d1 == k1)\n          mom_allele <- k2\n        if (d1 == k2)\n          mom_allele <- k1\n      }\n      if (d1 != d2 && k1 == k2) #the case where dad is het but off is hom\n      {\n        if (d1 == k1 || d2 == k1)\n          mom_allele <- k1;\n      }\n      if (d1 != d2 && k1 != k2) #if they're both hets you can't do anything with it.\n      mom_allele <- \".\"\n      if (d1 == \".\" || k1 == \".\")\n        mom_allele <- \".\"\n      return(c(y[1:9],mom.allele))\n    })\n\n  })\n  return(mat)\n}\n\n#' A function to merge two vcf data frames\n#' @param vcf1 A dataframe with genomic data in vcf format\n#' @param vcf2 A dataframe with genomic data in vcf format\n#' @param vcf.name A name for a file with the new vcf file (default is merge.vcf)\n#' @return vcf A new data.frame in vcf format\n#' @export\nmerge.vcfs<-function(vcf1,vcf2, vcf.name=\"merge.vcf\"){\n  vcf1<-extract.gt.vcf(vcf1)\n  vcf2<-extract.gt.vcf(vcf2)\n  col.id<-c(colnames(vcf1)[1:3],colnames(vcf1)[!(colnames(vcf1) %in%\n                                                   colnames(vcf2))])\n  vcf1a<-vcf1[,col.id]\n  vcf1a$index<-paste(vcf1a$`#CHROM`,vcf1a$ID,vcf1a$POS,sep=\".\")\n  vcf2$index<-paste(vcf2$`#CHROM`,vcf2$ID,vcf2$POS,sep=\".\")\n  vcf<-merge(vcf1a,vcf2, by=\"index\")\n  addedon<-vcf[duplicated(vcf$index),\"index\"]\n  if(!is.null(dim(addedon))) vcf<-vcf[!(vcf$index %in% addedon),]\n  drops<-c(\"index\",\"#CHROM.y\",\"POS.y\",\"ID.y\")\n  vcf<-vcf[,!(colnames(vcf) %in% drops)]\n  colnames(vcf)[1:3]<-c(\"CHROM\",\"POS\",\"ID\")\n  write.table(vcf,vcf.name,col.names=T,row.names=F,\n              quote=F,sep='\\t')\n  return(vcf)\n}\n\n#' Conduct selection components analysis\n#' @param vcf A data.frme with genotype data in vcf format\n#' @param locus.info A list of column names with the locus info (e.g. c(#CHROM,POS))\n#' @param group1 A list of column names with individuals from the first group\n#' @param group2 A list of column names with individuals from the second group\n#' @param prop.ind.thresh A proportion of indidivudals requried in each population (default is 0.5)\n#' @param maf.cutoff A minimum allele frequency cutoff (default is 0.05)\n#' @return sel A dataframe with the Fst values and Chi-squared values\n#' @export\ngwsca<-function(vcf,locus.info,group1,group2,prop.ind.thresh=0.5,maf.cutoff=0.05){\n  sel<-do.call(\"rbind\",apply(vcf,1,fst.one.vcf,c(locus.info,group1),c(locus.info,group2),\n    cov.thresh=prop.ind.thresh,maf=maf.cutoff))\n  sel<-sel[!is.na(sel$Fst),]\n  sel$Chi<-2*((sel$Num1+sel$Num2)/2)*sel$Fst\n  sel$Chi.p<-1-pchisq(sel$Chi,1)\n  sel$Chi.p.adj<-p.adjust(sel$Chi.p,method=\"BH\")\n  return(sel)\n}\n\n#' Calculate pairwise Fst values\n#' @param ped A dataframe with data in ped format, where each allele for each locus is in its own column\n#' @param allele1 An index for the first allele at the locus\n#' @param allele2 An index for the second allele at the locus\n#' @param pop.order A list with the Pop IDs in the correct order\n#' @return dat.var A matrix of pairwise fst values (calculated as (ht-hs)/ht)\n#' @export\npairwise.fst<-function(ped,allele1,allele2,pop.order){\n  #V1 of ped should be pop index\n  ped.split<-split(ped[,c(allele1,allele2)], factor(ped[,1]))\n  dat.var<-as.data.frame(setNames(\n    replicate(length(pop.order),numeric(0), simplify = F), pop.order))\n  for(i in 1:(length(pop.order)-1)){\n    for(j in (i+1):length(pop.order)){\n      pop1<-factor(ped.split[[pop.order[i]]][ped.split[[pop.order[i]]]!=\"0\"])\n      pop2<-factor(ped.split[[pop.order[j]]][ped.split[[pop.order[j]]]!=\"0\"])\n      freq1<-summary(pop1)/sum(summary(pop1))\n      freq2<-summary(pop2)/sum(summary(pop2))\n      freqall<-summary(as.factor(c(pop1,pop2)))/\n        sum(summary(as.factor(c(pop1,pop2))))\n      if(length(freq1)>1){ hs1<-2*freq1[1]*freq1[2]\n      } else {\n        hs1<-0\n      }\n      if(length(freq2)>1){ hs2<-2*freq2[1]*freq2[2]\n      } else {\n        hs2<-0\n      }\n      if(length(freqall)>1){\n        hs<-(hs1*length(pop1)+hs2*length(pop2))/(length(pop1)+length(pop2))\n        ht<-2*freqall[1]*freqall[2]\n        fst<-(ht-hs)/ht\n      }\n      if(length(freqall)<=1){ fst<-1 }\n      dat.var[pop.order[i],pop.order[j]]<-fst\n    }\n  }\n  dat.var<-rbind(dat.var,rep(NA, ncol(dat.var)))\n  rownames(dat.var)<-colnames(dat.var)\n  return(as.matrix(dat.var))\n}\n\n#' Calculate isolation by distance per locus\n#' @param ped.file A data.frame in ped format\n#' @param dist.mat A distance matrix containing the geeographic distances between populations\n#' @param pop.order A list with the order for the populations\n#' @return results.mantel A data.frame with two columns containing the mantel test results\n#' @export\nfst.ibd.byloc<-function(ped.file,dist.mat,pop.order){\n  results.mantel<-data.frame()\n  for(i in seq(7,ncol(ped.file),2)){\n    res<-mantel.rtest(\n      as.dist(t(pairwise.fst(ped.file,i,i+1,pop.order))),\n      as.dist(t(dist.mat)), nrepet=9999)\n    results.mantel<-rbind(results.mantel,cbind(res$obs,res$pvalue))\n  }\n  results.mantel<-as.data.frame(results.mantel)\n  colnames(results.mantel)<-c(\"Obs\",\"P\")\n  return(results.mantel)\n}\n\n#' Calculate pairwise Pst between population pairs\n#' @param dat A dataframe with the trait values, first column must be the pop ID\n#' @param pop.order A list of the order of the populations\n#' @return dat.var A data.frame with the pairwise Pst values\n#' @export\npairwise.pst<-function(dat, pop.order){\n  #first column must be pop id/grouping factor\n  library(nlme)\n  dat.split<-split(dat, factor(dat[,1]))\n  dat.var<-as.data.frame(setNames(\n    replicate(length(pop.order),numeric(0), simplify = F), pop.order))\n  for(i in 1:(length(pop.order)-1)){\n    for(j in (i+1):length(pop.order)){\n      temp.data<-rbind(as.data.frame(dat.split[[pop.order[i]]]),\n                       as.data.frame(dat.split[[pop.order[j]]]))\n      colnames(temp.data)<-c(\"PopID\",\"Var\")\n      temp.data$PopID<-factor(temp.data$PopID)\n      anv <- lme(fixed=Var ~ 1, random=~1|PopID,data=temp.data)\n      varcomp <- VarCorr(anv)\n      v.btwn<- as.numeric(varcomp[1])\n      v.wthn <- as.numeric(varcomp[2])\n      pst <- v.btwn/(v.btwn+2*v.wthn)\n      dat.var[pop.order[i],pop.order[j]]<-pst\n      #aov.var<-summary.aov(\n      #\taov(temp.data[,2]~temp.data[,1]))[[1]]$`Sum Sq`\n      #aov.df<-summary.aov(\n      #\taov(temp.data[,2]~temp.data[,1]))[[1]]$`Df`\n      #dat.var[pop.order[i],pop.order[j]]<-aov.var[2]/(aov.var[2]+\n      #\t(2*(aov.var[1]/(aov.df[2]-1))))\n    }\n  }\n  dat.var<-rbind(dat.var,rep(NA, ncol(dat.var)))\n  rownames(dat.var)<-colnames(dat.var)\n  return(dat.var)\n}\n\n#' Calulate pairwise Psts and test for IBD\n#' @param trait.df A data frame with trait values for all traits and all individuals\n#' @param comp.df A dataframe with the distance values\n#' @param id.index The index value for the trait being calculated\n#' @return results.mantel A data.frame with the results of the mantel test\n#' @export\nall.traits.pst.mantel<-function(trait.df,comp.df,id.index){\n  results.mantel<-data.frame()\n  for(i in 3:ncol(trait.df)){\n    res<-mantel.rtest(\n      as.dist(t(pairwise.pst(trait.df[,c(id.index,i)],pop.order))),\n      as.dist(t(comp.df)), nrepet=9999)\n    results.mantel<-rbind(results.mantel,cbind(res$obs,res$pvalue))\n  }\n  results.mantel<-as.data.frame(results.mantel)\n  rownames(results.mantel)<-colnames(trait.df)[3:ncol(trait.df)]\n  colnames(results.mantel)<-c(\"Obs\",\"P\")\n  return(results.mantel)\n}\n\n\n#' Compare Pst and Fst locus by locus from a ped file\n#' @param ped.file A data.frame with data in ped format\n#' @param trait.df A data.frame containing all of the traits data\n#' @param pop.order An order in which the populations should be analyzed\n#' @param trait.ind The trait index in the trait.df\n#' @return results.list A dataframe containing the restuls of the mantel test (one column for observations and one for p-values)\n#' @export\nfst.pst.byloc<-function(ped.file,trait.df,pop.order,trait.ind){\n  results.list<-list()\n  for(j in 3:ncol(trait.df)){\n    results.mantel<-data.frame()\n    for(i in seq(7,ncol(ped.file),2)){\n      res<-mantel.rtest(\n        as.dist(t(pairwise.fst(ped.file,i,i+1,pop.order))),\n        as.dist(t(pairwise.pst(trait.df[,c(trait.ind,j)],pop.order))),\n        nrepet=9999)\n      results.mantel<-rbind(results.mantel,cbind(res$obs,res$pvalue))\n    }\n    results.mantel<-as.data.frame(results.mantel)\n    colnames(results.mantel)<-c(\"Obs\",\"P\")\n    results.list<-append(results.list,data.frame(results.mantel))\n  }\n  #names(results.list)<-colnames(trait.df)[3:ncol(trait.df)]\n  return(results.list)\n}\n\n#' Calculate the standard error of the mean\n#' @param x A list of values\n#' @return sem A value of the standard error of the mean\n#' @export\nsem<-function(x){\n  sem<-sd(x)/sqrt(length(x))\n  return(sem)\n}\n\n\n#' A function to reorder a data.frame\n#' @param dat A data.frame. Group ID should be in column 1\n#' @param order.list A list of factors for reordering\n#' @return dat.new The reordered dataframe\n#' @export\nreorder.df<-function(dat,order.list){\n  #dat has to have the grouping IDs in row 1\n  #those grouping ids must match the factors in order.list\n  dat.sep<-split(dat, dat[,1])\n  dat.new<-dat.sep[[order.list[1]]]\n  for(i in 2:length(order.list)){\n    dat.new<-rbind(dat.new, dat.sep[[order.list[i]]])\n  }\n  return(dat.new)\n}\n\n#' This plots the output of structure\n#' @param structure.out A data.frame containing the structure output.\n#' @param k The value of K used in Structure\n#' @param pop.order The order in which the populations are plotted.\n#' @param filename The name of the jpeg for the output file.\n#' @param make.file A boolean (TRUE/FALSE) indicating whether the jpeg should be created\n#' @param plot.new A boolean (TRUE/FALSE) indicating whether this is being added to an existing plot\n#' @param colors A list of colors for the structure colors (if not provided, defaults to rainbow palette)\n#' @param xlabel A boolean (TRUE/FALSE) indicating whether x labels should be plotted (default is TRUE)\n#' @param ylabel An optional label for the y-axis.\n#' @export\nplotting.structure<-function(structure.out, k, pop.order,\n                             filename=paste(\"str.k\",k,\".jpeg\",sep=\"\"),make.file=TRUE,\n                             plot.new=TRUE,colors=NULL,xlabel=TRUE,ylabel=NULL){\n  str.split<-split(structure.out,structure.out[,1])\n  if(is.null(colors)){\n    bar.colors<-rainbow(k,s=0.5)\n  } else {\n    bar.colors<-colors\n  }\n  if(make.file==TRUE){\n    jpeg(filename,width=7, height=1.25, units=\"in\", res=300)\n    par(mfrow=c(1,length(str.split)))\n  }\n  #par(mfrow=c(1,length(str.split)),mar=c(1,0,0,0), oma=c(1,0,0,0),cex=0.5)\n  for(i in 1:length(str.split)){\n    pop.index<-pop.order[i]\n    barplot(height=as.matrix(t(str.split[[pop.index]][,-1])),\n            beside=FALSE, space=0,\tborder=NA, col=bar.colors,\n            xlab=\"\", ylab=\"\", xaxt='n', yaxt='n')#, new=plot.new)\n    if(xlabel==TRUE){\n      mtext(pop.index, 1, line=0.5, cex=1, outer=F)}\n    if(!is.null(ylabel)){\n      if(i == 1) { mtext(ylabel,2,cex=1) }\n    }\n  }\n  if(make.file==TRUE) {dev.off()}\n}\n\n\n\n",
    "created" : 1485126154261.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "36|42|148|0|\n158|30|165|0|\n186|43|225|0|\n435|28|465|0|\n496|60|534|0|\n649|54|682|0|\n708|39|737|0|\n801|37|810|0|\n",
    "hash" : "657237961",
    "id" : "A8ACF9FA",
    "lastKnownWriteTime" : 1485134092,
    "last_content_update" : -2147483648,
    "path" : "~/GitHub/gwscaR/R/gwscaR.R",
    "project_path" : "R/gwscaR.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}